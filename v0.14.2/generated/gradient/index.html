<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gradient of a scalar field · PencilFFTs.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://jipolanco.github.io/PencilFFTs.jl/generated/gradient/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/><script src="../../assets/tomate.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="PencilFFTs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PencilFFTs.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Gradient of a scalar field</a><ul class="internal"><li><a class="tocitem" href="#General-procedure"><span>General procedure</span></a></li><li><a class="tocitem" href="#Preparation"><span>Preparation</span></a></li><li><a class="tocitem" href="#Fourier-wave-numbers"><span>Fourier wave numbers</span></a></li><li><a class="tocitem" href="#gradient_method_global"><span>Method 1: global views</span></a></li><li><a class="tocitem" href="#gradient_method_global_explicit"><span>Method 2: explicit global indexing</span></a></li><li><a class="tocitem" href="#gradient_method_local"><span>Method 3: using local indices</span></a></li><li><a class="tocitem" href="#gradient_method_broadcast"><span>Method 4: using broadcasting</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li><li><a class="tocitem" href="#gradient_benchmarks"><span>Benchmark results</span></a></li></ul></li><li><a class="tocitem" href="../navier_stokes/">Navier–Stokes equations</a></li><li><a class="tocitem" href="../in-place/">In-place transforms</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../PencilFFTs/">Distributed FFT plans</a></li><li><a class="tocitem" href="../../Transforms/">Available transforms</a></li><li><a class="tocitem" href="../../PencilFFTs_timers/">Measuring performance</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../GlobalFFTParams/">Global FFT parameters</a></li></ul></li></ul></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Gradient of a scalar field</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Gradient of a scalar field</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jipolanco/PencilFFTs.jl/blob/master/docs/examples/gradient.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Gradient-of-a-scalar-field"><a class="docs-heading-anchor" href="#Gradient-of-a-scalar-field">Gradient of a scalar field</a><a id="Gradient-of-a-scalar-field-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-of-a-scalar-field" title="Permalink"></a></h1><p>This example shows different methods to compute the gradient of a real-valued 3D scalar field <span>$θ(\bm{x})$</span> in Fourier space, where <span>$\bm{x} = (x, y, z)$</span>. It is assumed that the field is periodic with period <span>$L = 2π$</span> along all dimensions.</p><h2 id="General-procedure"><a class="docs-heading-anchor" href="#General-procedure">General procedure</a><a id="General-procedure-1"></a><a class="docs-heading-anchor-permalink" href="#General-procedure" title="Permalink"></a></h2><p>The discrete Fourier expansion of <span>$θ$</span> writes</p><p class="math-container">\[θ(\bm{x}) = ∑_{\bm{k} ∈ \Z^3} \hat{θ}(\bm{k}) \, e^{i \bm{k} ⋅ \bm{x}},\]</p><p>where <span>$\bm{k} = (k_x, k_y, k_z)$</span> are the Fourier wave numbers and <span>$\hat{θ}$</span> is the discrete Fourier transform of <span>$θ$</span>. Then, the spatial derivatives of <span>$θ$</span> are given by</p><p class="math-container">\[\frac{∂ θ(\bm{x})}{∂ x_i} =
∑_{\bm{k} ∈ \Z^3} i k_i \hat{θ}(\bm{k}) \, e^{i \bm{k} ⋅ \bm{x}},\]</p><p>where the subscript <span>$i$</span> denotes one of the spatial components <span>$x$</span>, <span>$y$</span> or <span>$z$</span>.</p><p>In other words, to compute <span>$\bm{∇} θ = (∂_x θ, ∂_y θ, ∂_z θ)$</span>, one has to:</p><ol><li>transform <span>$θ$</span> to Fourier space to obtain <span>$\hat{θ}$</span>,</li><li>multiply <span>$\hat{θ}$</span> by <span>$i \bm{k}$</span>,</li><li>transform the result back to physical space to obtain <span>$\bm{∇} θ$</span>.</li></ol><h2 id="Preparation"><a class="docs-heading-anchor" href="#Preparation">Preparation</a><a id="Preparation-1"></a><a class="docs-heading-anchor-permalink" href="#Preparation" title="Permalink"></a></h2><p>In this section, we initialise a random real-valued scalar field <span>$θ$</span> and compute its FFT. For more details see the <a href="../../tutorial/#Tutorial">Tutorial</a>.</p><pre><code class="language-julia hljs">using MPI
using PencilFFTs
using Random

MPI.Init()

# Input data dimensions (Nx × Ny × Nz)
dims = (64, 32, 64)

# Apply a 3D real-to-complex (r2c) FFT.
transform = Transforms.RFFT()

# Automatically create decomposition configuration
comm = MPI.COMM_WORLD
pen = Pencil(dims, comm)

# Create plan
plan = PencilFFTPlan(pen, transform)

# Allocate data and initialise field
θ = allocate_input(plan)
randn!(θ)

# Perform distributed FFT
θ_hat = plan * θ</code></pre><p>Finally, we initialise the output that will hold ∇θ in Fourier space. Noting that ∇θ is a vector field, we choose to store it as a tuple of 3 PencilArrays.</p><pre><code class="language-julia hljs">∇θ_hat = allocate_output(plan, Val(3))

# This is equivalent:
# ∇θ_hat = ntuple(d -&gt; similar(θ_hat), Val(3))

summary(∇θ_hat)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;Tuple{PencilArray{ComplexF64, 3, Array{ComplexF64, 3}, 3, 0, Pencil{3, 2, Permutation{(3, 2, 1), 3}, Vector{UInt8}}}, PencilArray{ComplexF64, 3, Array{ComplexF64, 3}, 3, 0, Pencil{3, 2, Permutation{(3, 2, 1), 3}, Vector{UInt8}}}, PencilArray{ComplexF64, 3, Array{ComplexF64, 3}, 3, 0, Pencil{3, 2, Permutation{(3, 2, 1), 3}, Vector{UInt8}}}}&quot;</code></pre><h2 id="Fourier-wave-numbers"><a class="docs-heading-anchor" href="#Fourier-wave-numbers">Fourier wave numbers</a><a id="Fourier-wave-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Fourier-wave-numbers" title="Permalink"></a></h2><p>In general, the Fourier wave numbers are of the form <span>$k_i = 0, ±\frac{2π}{L_i}, ±\frac{4π}{L_i}, ±\frac{6π}{L_i}, …$</span>, where <span>$L_i$</span> is the period along dimension <span>$i$</span>. When a real-to-complex Fourier transform is applied, roughly half of these wave numbers are redundant due to the Hermitian symmetry of the complex Fourier coefficients. In practice, this means that for the fastest dimension <span>$x$</span> (along which a real-to-complex transform is performed), the negative wave numbers are dropped, i.e. <span>$k_x = 0, \frac{2π}{L_x}, \frac{4π}{L_x}, …$</span>.</p><p>The <code>AbstractFFTs</code> package provides a convenient way to generate the Fourier wave numbers, using the functions <a href="https://juliamath.github.io/AbstractFFTs.jl/stable/api/#AbstractFFTs.fftfreq"><code>fftfreq</code></a> and <a href="https://juliamath.github.io/AbstractFFTs.jl/stable/api/#AbstractFFTs.rfftfreq"><code>rfftfreq</code></a>. We can use these functions to initialise a &quot;grid&quot; of wave numbers associated to our 3D real-to-complex transform:</p><pre><code class="language-julia hljs">using AbstractFFTs: fftfreq, rfftfreq

box_size = (2π, 2π, 2π)  # Lx, Ly, Lz
sample_rate = 2π .* dims ./ box_size

# In our case (Lx = 2π and Nx even), this gives kx = [0, 1, 2, ..., Nx/2].
kx = rfftfreq(dims[1], sample_rate[1])

# In our case (Ly = 2π and Ny even), this gives
# ky = [0, 1, 2, ..., Ny/2-1, -Ny/2, -Ny/2+1, ..., -1] (and similarly for kz).
ky = fftfreq(dims[2], sample_rate[2])
kz = fftfreq(dims[3], sample_rate[3])

kvec = (kx, ky, kz)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0  …  23.0, 24.0, 25.0, 26.0, 27.0, 28.0, 29.0, 30.0, 31.0, 32.0], [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0  …  -10.0, -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0], [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0  …  -10.0, -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0])</code></pre><p>Note that <code>kvec</code> now contains the wave numbers associated to the global domain. In the following, we will only need the wave numbers associated to the portion of the domain handled by the local MPI process.</p><h2 id="gradient_method_global"><a class="docs-heading-anchor" href="#gradient_method_global">Method 1: global views</a><a id="gradient_method_global-1"></a><a class="docs-heading-anchor-permalink" href="#gradient_method_global" title="Permalink"></a></h2><p><a href="https://jipolanco.github.io/PencilArrays.jl/dev/PencilArrays/#PencilArrays.PencilArray"><code>PencilArray</code></a>s, returned for instance by <a href="../../PencilFFTs/#PencilFFTs.allocate_input"><code>allocate_input</code></a> and  <a href="../../PencilFFTs/#PencilFFTs.allocate_output"><code>allocate_output</code></a>, take indices that start at 1, regardless of the location of the subdomain associated to the local process on the global grid. (In other words, <code>PencilArray</code>s take <em>local</em> indices.) On the other hand, we have defined the wave number vector <code>kvec</code> which, for each MPI process, is defined over the global domain, and as such it takes <em>global</em> indices.</p><p>One straightforward way of making data arrays compatible with wave numbers is to use global views, i.e. arrays that take global indices. These are generated from <code>PencilArray</code>s by calling the <a href="https://jipolanco.github.io/PencilArrays.jl/dev/PencilArrays/#PencilArrays.global_view-Tuple{PencilArray}"><code>global_view</code></a> function. Note that, in general, global indices do <em>not</em> start at 1 for a given MPI process. A given process will own a range of data given by indices in <code>(i1:i2, j1:j2, k1:k2)</code>.</p><pre><code class="language-julia hljs">θ_glob = global_view(θ_hat)
∇θ_glob = global_view.(∇θ_hat)
summary(θ_glob)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;16×32×64 OffsetArray(::PencilArray{ComplexF64, 3}, 1:16, 1:32, 1:64) with eltype ComplexF64 with indices 1:16×1:32×1:64&quot;</code></pre><p>Once we have global views, we can combine data and wave numbers using the portion of global indices owned by the local MPI process, as shown below. We can use <code>CartesianIndices</code> to iterate over the global indices associated to the local process.</p><pre><code class="language-julia hljs">for I in CartesianIndices(θ_glob)
    i, j, k = Tuple(I)  # unpack indices

    # Wave number vector associated to current Cartesian index.
    kx = kvec[1][i]
    ky = kvec[2][j]
    kz = kvec[3][k]

    # Compute gradient in Fourier space.
    # Note that modifying ∇θ_glob also modifies the original PencilArray ∇θ_hat.
    ∇θ_glob[1][I] = im * kx * θ_glob[I]
    ∇θ_glob[2][I] = im * ky * θ_glob[I]
    ∇θ_glob[3][I] = im * kz * θ_glob[I]
end</code></pre><p>The above loop can be written in a slightly more efficient manner by precomputing <code>im * θ_glob[I]</code>:</p><pre><code class="language-julia hljs">@inbounds for I in CartesianIndices(θ_glob)
    i, j, k = Tuple(I)

    kx = kvec[1][i]
    ky = kvec[2][j]
    kz = kvec[3][k]

    u = im * θ_glob[I]

    ∇θ_glob[1][I] = kx * u
    ∇θ_glob[2][I] = ky * u
    ∇θ_glob[3][I] = kz * u
end</code></pre><p>Also note that the above can be easily written in a more generic way, e.g. for arbitrary dimensions, thanks in part to the use of <code>CartesianIndices</code>. Moreover, in the above there is no notion of the dimension permutations discussed in <a href="../../tutorial/#tutorial:output_data_layout">the tutorial</a>, as it is all hidden behind the implementation of <code>PencilArray</code>s. And as seen later in the <a href="#gradient_benchmarks">benchmarks</a>, these (hidden) permutations have zero cost, as the speed is identical to that of a function that explicitly takes into account these permutations.</p><p>Finally, we can perform a backwards transform to obtain <span>$\bm{∇} θ$</span> in physical space:</p><pre><code class="language-julia hljs">∇θ = plan \ ∇θ_hat;</code></pre><p>Note that the transform is automatically broadcast over the three fields of the <code>∇θ_hat</code> vector, and the result <code>∇θ</code> is also a tuple of three <code>PencilArray</code>s.</p><h2 id="gradient_method_global_explicit"><a class="docs-heading-anchor" href="#gradient_method_global_explicit">Method 2: explicit global indexing</a><a id="gradient_method_global_explicit-1"></a><a class="docs-heading-anchor-permalink" href="#gradient_method_global_explicit" title="Permalink"></a></h2><p>Sometimes, one does not need to write generic code. In our case, one often knows the dimensionality of the problem and the memory layout of the data (i.e. the underlying index permutation).</p><p>Below is a reimplementation of the above loop, using explicit indices instead of <code>CartesianIndices</code>, and assuming that the underlying index permutation is <code>(3, 2, 1)</code>, that is, data is stored in <span>$(z, y, x)$</span> order. As discussed in <a href="../../tutorial/#tutorial:output_data_layout">the tutorial</a>, this is the default for transformed arrays. This example also serves as a more explicit explanation for what is going on in the <a href="#gradient_method_global">first method</a>.</p><pre><code class="language-julia hljs"># Get local data range in the global grid.
rng = axes(θ_glob)  # = (i1:i2, j1:j2, k1:k2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(OffsetArrays.IdOffsetRange(values=1:16, indices=1:16), OffsetArrays.IdOffsetRange(values=1:32, indices=1:32), OffsetArrays.IdOffsetRange(values=1:64, indices=1:64))</code></pre><p>For the loop below, we&#39;re assuming that the permutation is (3, 2, 1). In other words, the fastest index is the <em>last</em> one, and not the first one as it is usually in Julia. If the permutation is not (3, 2, 1), things will still work (well, except for the assertion below!), but the loop order will not be optimal.</p><pre><code class="language-julia hljs">@assert permutation(θ_hat) === Permutation(3, 2, 1)

@inbounds for i in rng[1], j in rng[2], k in rng[3]
    kx = kvec[1][i]
    ky = kvec[2][j]
    kz = kvec[3][k]

    # Note that we still access the arrays in (i, j, k) order.
    # (The permutation happens behind the scenes!)
    u = im * θ_glob[i, j, k]

    ∇θ_glob[1][i, j, k] = kx * u
    ∇θ_glob[2][i, j, k] = ky * u
    ∇θ_glob[3][i, j, k] = kz * u
end</code></pre><h2 id="gradient_method_local"><a class="docs-heading-anchor" href="#gradient_method_local">Method 3: using local indices</a><a id="gradient_method_local-1"></a><a class="docs-heading-anchor-permalink" href="#gradient_method_local" title="Permalink"></a></h2><p>Alternatively, we can avoid global views and work directly on <code>PencilArray</code>s using local indices that start at 1. In this case, part of the strategy is to construct a &quot;local&quot; grid of wave numbers that can also be accessed with local indices. This can be conveniently done using the <a href="https://jipolanco.github.io/PencilArrays.jl/dev/LocalGrids/#PencilArrays.LocalGrids.localgrid"><code>localgrid</code></a> function of the PencilArrays.jl package, which accepts a <code>PencilArray</code> (or its associated <code>Pencil</code>) and the global coordinates (here <code>kvec</code>):</p><pre><code class="language-julia hljs">grid_fourier = localgrid(θ_hat, kvec)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LocalRectilinearGrid{3} with Permutation(3, 2, 1) and coordinates:
 (1) [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0]
 (2) [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, -16.0, -15.0, -14.0, -13.0, -12.0, -11.0, -10.0, -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0]
 (3) [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 26.0, 27.0, 28.0, 29.0, 30.0, 31.0, -32.0, -31.0, -30.0, -29.0, -28.0, -27.0, -26.0, -25.0, -24.0, -23.0, -22.0, -21.0, -20.0, -19.0, -18.0, -17.0, -16.0, -15.0, -14.0, -13.0, -12.0, -11.0, -10.0, -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0]</code></pre><p>Note that one can directly iterate on the returned grid object:</p><pre><code class="language-julia hljs">@inbounds for I in CartesianIndices(grid_fourier)
    # Wave number vector associated to current Cartesian index.
    k⃗ = grid_fourier[I]
    u = im * θ_hat[I]
    ∇θ_hat[1][I] = k⃗[1] * u
    ∇θ_hat[2][I] = k⃗[2] * u
    ∇θ_hat[3][I] = k⃗[3] * u
end</code></pre><p>This implementation is as efficient as the other examples, while being slightly shorter to write. Moreover, it is quite generic, and can be made independent of the number of dimensions with little effort.</p><h2 id="gradient_method_broadcast"><a class="docs-heading-anchor" href="#gradient_method_broadcast">Method 4: using broadcasting</a><a id="gradient_method_broadcast-1"></a><a class="docs-heading-anchor-permalink" href="#gradient_method_broadcast" title="Permalink"></a></h2><p>Finally, note that the local grid object returned by <code>localgrid</code> makes it is possible to compute the gradient using broadcasting, thus fully avoiding scalar indexing. This can be quite convenient in some cases, and can also be very useful if one is working on GPUs (where scalar indexing is prohibitively expensive). Using broadcasting, the above examples simply become:</p><pre><code class="language-julia hljs">@. ∇θ_hat[1] = im * grid_fourier[1] * θ_hat
@. ∇θ_hat[2] = im * grid_fourier[2] * θ_hat
@. ∇θ_hat[3] = im * grid_fourier[3] * θ_hat</code></pre><p>Once again, as shown in the <a href="#gradient_benchmarks">benchmarks</a> further below, this method performs quite similarly to the other ones.</p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>The <code>PencilArrays</code> module provides different alternatives to deal with MPI-distributed data that may be subject to dimension permutations. In particular, one can choose to work with <em>global</em> indices (first two examples), with <em>local</em> indices (third example), or to avoid scalar indexing altogether (fourth example).</p><p>If one wants to stay generic, making sure that the same code will work for arbitrary dimensions and will be efficient regardless of the underlying dimension permutation, methods <a href="#gradient_method_global">1</a>, <a href="#gradient_method_local">3</a> or <a href="#gradient_method_broadcast">4</a> should be preferred. These use <code>CartesianIndices</code> and make no assumptions on possible dimension permutations, which are by default enabled in the output of PencilFFTs transforms. In fact, such permutations are completely invisible in the implementations.</p><p>The <a href="#gradient_method_global_explicit">second method</a> uses explicit <code>(i, j, k)</code> indices. It assumes that the underlying permutation is <code>(3, 2, 1)</code> to loop with <code>i</code> as the <em>slowest</em> index and <code>k</code> as the <em>fastest</em>, which is the optimal order in this case given the permutation. As such, the implementation is less generic than the others, and differences in performance are negligible with respect to more generic variants.</p><h2 id="gradient_benchmarks"><a class="docs-heading-anchor" href="#gradient_benchmarks">Benchmark results</a><a id="gradient_benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#gradient_benchmarks" title="Permalink"></a></h2><p>The following are the benchmark results obtained from running <a href="https://github.com/jipolanco/PencilFFTs.jl/blob/master/examples/gradient.jl"><code>examples/gradient.jl</code></a> on a laptop, using 2 MPI processes and Julia 1.7.2, with an input array of global dimensions <span>$64 × 32 × 64$</span>. The different methods detailed above are marked on the right. The &quot;lazy&quot; marks indicate runs where the wave numbers were represented by lazy <code>Frequencies</code> objects (returned by <code>rfftfreq</code> and <code>fftfreq</code>). Otherwise, they were collected into <code>Vector</code>s. For some reason, plain <code>Vector</code>s are faster when working with grids generated by <code>localgrid</code>.</p><p>In the script, additional implementations can be found which rely on a more advanced understanding of permutations and on the internals of the <a href="https://jipolanco.github.io/PencilArrays.jl/dev/"><code>PencilArrays</code></a> package. For instance, <code>gradient_local_parent!</code> directly works with the raw data stored in Julia <code>Array</code>s, while <code>gradient_local_linear!</code> completely avoids <code>CartesianIndices</code> while staying generic and efficient. Nevertheless, these display roughly the same performance as the above examples.</p><pre><code class="nohighlight hljs">    gradient_global_view!...                  89.900 μs
    gradient_global_view! (lazy)...           92.060 μs  [Method 1]
    gradient_global_view_explicit!...         88.958 μs
    gradient_global_view_explicit! (lazy)...  81.055 μs  [Method 2]
    gradient_local!...                        92.305 μs
    gradient_grid!...                         92.770 μs
    gradient_grid! (lazy)...                  101.388 μs  [Method 3]
    gradient_grid_broadcast!...               88.606 μs
    gradient_grid_broadcast! (lazy)...        151.020 μs  [Method 4]
    gradient_local_parent!...                 92.248 μs
    gradient_local_linear!...                 91.212 μs
    gradient_local_linear_explicit!...        90.992 μs</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../navier_stokes/">Navier–Stokes equations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 5 October 2022 10:09">Wednesday 5 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
