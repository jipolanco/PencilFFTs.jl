<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · PencilFFTs.jl</title><link rel="canonical" href="https://jipolanco.github.io/PencilFFTs.jl/tutorial/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><script src="../assets/matomo.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="PencilFFTs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PencilFFTs.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#tutorial:creating_plans"><span>Creating plans</span></a></li><li><a class="tocitem" href="#Allocating-data"><span>Allocating data</span></a></li><li><a class="tocitem" href="#Applying-plans"><span>Applying plans</span></a></li><li><a class="tocitem" href="#Accessing-and-modifying-data"><span>Accessing and modifying data</span></a></li><li><a class="tocitem" href="#Parallel-I/O"><span>Parallel I/O</span></a></li><li><a class="tocitem" href="#Further-reading"><span>Further reading</span></a></li></ul></li><li><span class="tocitem">More examples</span><ul><li><a class="tocitem" href="../examples/in-place/">In-place transforms</a></li><li><a class="tocitem" href="../examples/gradient/">Gradient of a scalar field</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../PencilFFTs/">Distributed FFT plans</a></li><li><a class="tocitem" href="../Transforms/">Available transforms</a></li><li><a class="tocitem" href="../PencilFFTs_timers/">Measuring performance</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../GlobalFFTParams/">Global FFT parameters</a></li></ul></li></ul></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jipolanco/PencilFFTs.jl/blob/master/docs/src/tutorial.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>The following tutorial shows how to perform a 3D FFT of real periodic data defined on a grid of <span>$N_x × N_y × N_z$</span> points.</p><div class="figure">
  <!--
  Note: this is evaluated from the directory where the Tutorial page is
  built. This directory varies depending on whether `prettyurls` is enabled in
  `makedocs`. Here we assume `prettyurls=true`.
  -->
  <img
    width="85%"
    src="../img/pencils.svg"
    alt="Pencil decomposition of 3D domains">
</div><p>The example assumes that 12 MPI processes are available. The data is to be distributed on a 2D MPI topology of dimensions <span>$3 × 4$</span>, as represented in the above figure.</p><h2 id="tutorial:creating_plans"><a class="docs-heading-anchor" href="#tutorial:creating_plans">Creating plans</a><a id="tutorial:creating_plans-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial:creating_plans" title="Permalink"></a></h2><p>The first thing to do is to create a <a href="../PencilFFTs/#PencilFFTs.PencilFFTPlan"><code>PencilFFTPlan</code></a>, which requires information on the global dimensions <span>$N_x × N_y × N_z$</span> of the data, on the transforms that will be applied, and on the way the data is distributed among MPI processes (i.e. number of processes along each dimension):</p><pre><code class="language-julia">using MPI
using PencilFFTs

MPI.Init()

# Input data dimensions (Nx × Ny × Nz)
dims = (16, 32, 64)

# Apply a 3D real-to-complex (r2c) FFT.
transform = Transforms.RFFT()

# For more control, one can instead separately specify the transforms along each dimension:
# transform = (Transforms.RFFT(), Transforms.FFT(), Transforms.FFT())

# MPI topology information
comm = MPI.COMM_WORLD  # we assume MPI.Comm_size(comm) == 12
proc_dims = (3, 4)     # 3 processes along `y`, 4 along `z`

# Create plan
plan = PencilFFTPlan(dims, transform, proc_dims, comm)</code></pre><p>See the <a href="../PencilFFTs/#PencilFFTs.PencilFFTPlan"><code>PencilFFTPlan</code></a> constructor for details on the accepted options, and the <a href="../Transforms/#PencilFFTs.Transforms"><code>Transforms</code></a> module for the possible transforms. It is also possible to enable fine-grained performance measurements via the <a href="https://github.com/KristofferC/TimerOutputs.jl">TimerOutputs</a> package, as described in <a href="../PencilFFTs_timers/#PencilFFTs.measuring_performance">Measuring performance</a>.</p><h2 id="Allocating-data"><a class="docs-heading-anchor" href="#Allocating-data">Allocating data</a><a id="Allocating-data-1"></a><a class="docs-heading-anchor-permalink" href="#Allocating-data" title="Permalink"></a></h2><p>Next, we want to apply the plan on some data. Transforms may only be applied on <a href="https://jipolanco.github.io/PencilArrays.jl/dev/PencilArrays/"><code>PencilArray</code></a>s, which are array wrappers that include MPI decomposition information (in some sense, analogous to <a href="https://github.com/JuliaParallel/Distributedarrays.jl"><code>DistributedArray</code></a>s in Julia&#39;s distributed computing approach). The helper function <a href="../PencilFFTs/#PencilFFTs.allocate_input"><code>allocate_input</code></a> can be used to allocate a <code>PencilArray</code> that is compatible with our plan:</p><pre><code class="language-julia"># In our example, this returns a 3D PencilArray of real data (Float64).
u = allocate_input(plan)

# Fill the array with some (random) data
using Random
randn!(u)</code></pre><p><code>PencilArray</code>s are a subtype of <code>AbstractArray</code>, and thus they support all common array operations.</p><p>Similarly, to preallocate output data, one can use <a href="../PencilFFTs/#PencilFFTs.allocate_output"><code>allocate_output</code></a>:</p><pre><code class="language-julia"># In our example, this returns a 3D PencilArray of complex data (Complex{Float64}).
v = allocate_output(plan)</code></pre><p>This is only required if one wants to apply the plans using a preallocated output (with <code>mul!</code>, see right below).</p><p>The data types returned by <a href="../PencilFFTs/#PencilFFTs.allocate_input"><code>allocate_input</code></a> and <a href="../PencilFFTs/#PencilFFTs.allocate_output"><code>allocate_output</code></a> are slightly different when working with in-place transforms. See the <a href="../examples/in-place/#In-place-transforms">in-place example</a> for details.</p><h2 id="Applying-plans"><a class="docs-heading-anchor" href="#Applying-plans">Applying plans</a><a id="Applying-plans-1"></a><a class="docs-heading-anchor-permalink" href="#Applying-plans" title="Permalink"></a></h2><p>The interface to apply plans is consistent with that of <a href="https://juliamath.github.io/AbstractFFTs.jl/stable/api/#AbstractFFTs.plan_fft"><code>AbstractFFTs</code></a>. Namely, <code>*</code> and <code>mul!</code> are respectively used for forward transforms without and with preallocated output data. Similarly, <code>\</code> and <code>ldiv!</code> are used for backward transforms.</p><pre><code class="language-julia">using LinearAlgebra  # for mul!, ldiv!

# Apply plan on `u` with `v` as an output
mul!(v, plan, u)

# Apply backward plan on `v` with `w` as an output
w = similar(u)
ldiv!(w, plan, v)  # now w ≈ u</code></pre><p>Note that, consistently with <code>AbstractFFTs</code>, normalisation is performed at the end of a backward transform, so that the original data is recovered when applying a forward followed by a backward transform.</p><h2 id="Accessing-and-modifying-data"><a class="docs-heading-anchor" href="#Accessing-and-modifying-data">Accessing and modifying data</a><a id="Accessing-and-modifying-data-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-and-modifying-data" title="Permalink"></a></h2><p>For any given MPI process, a <code>PencilArray</code> holds the data associated to its local partition in the global geometry. <code>PencilArray</code>s are accessed using local indices that start at 1, regardless of the location of the local process in the MPI topology. Note that <code>PencilArray</code>s, being based on regular <code>Array</code>s, support both linear and Cartesian indexing (see <a href="https://docs.julialang.org/en/latest/manual/arrays/#Number-of-indices-1">the Julia docs</a> for details).</p><p>For convenience, the <a href="https://jipolanco.github.io/PencilArrays.jl/dev/PencilArrays/#Global-views"><code>global_view</code></a> function can be used to generate an <a href="https://github.com/JuliaArrays/OffsetArrays.jl"><code>OffsetArray</code></a> wrapper that takes global indices.</p><h3 id="tutorial:output_data_layout"><a class="docs-heading-anchor" href="#tutorial:output_data_layout">Output data layout</a><a id="tutorial:output_data_layout-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial:output_data_layout" title="Permalink"></a></h3><p>In memory, the dimensions of the transform output are by default reversed with respect to the input. That is, if the order of indices in the input data is <code>(x, y, z)</code>, then the output has order <code>(z, y, x)</code> in memory. This detail is hidden from the user, and <strong>output arrays are always accessed in the same order as the input data</strong>, regardless of the underlying output dimension permutation. This applies to <code>PencilArray</code>s and to <code>OffsetArray</code>s returned by <a href="https://jipolanco.github.io/PencilArrays.jl/dev/PencilArrays/#PencilArrays.global_view-Tuple{PencilArray}"><code>global_view</code></a>.</p><p>The reasoning behind dimension permutations, is that they allow to always perform FFTs along the fastest array dimension and to avoid a local data transposition, resulting in performance gains. A similar approach is followed by other parallel FFT libraries. FFTW itself, in its distributed-memory routines, <a href="http://fftw.org/doc/Transposed-distributions.html#Transposed-distributions">includes a flag</a> that enables a similar behaviour. In PencilFFTs, index permutation is the default, but it can be disabled via the <code>permute_dims</code> flag of <a href="../PencilFFTs/#PencilFFTs.PencilFFTPlan"><code>PencilFFTPlan</code></a>.</p><p>A great deal of work has been spent in making generic index permutations as efficient as possible, both in intermediate and in the output state of the multidimensional transforms. This has been achieved, in part, by making sure that permutations such as <code>(3, 2, 1)</code> are compile-time constants.</p><h2 id="Parallel-I/O"><a class="docs-heading-anchor" href="#Parallel-I/O">Parallel I/O</a><a id="Parallel-I/O-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-I/O" title="Permalink"></a></h2><p>It is possible to read and write <code>PencilArray</code>s to disk using <a href="https://portal.hdfgroup.org/display/HDF5/Parallel+HDF5">Parallel HDF5</a> via the <a href="https://github.com/JuliaIO/HDF5.jl">HDF5.jl</a> package. Assuming <a href="https://jipolanco.github.io/PencilArrays.jl/dev/PencilIO/#setting_up_parallel_hdf5">everything is set-up correctly</a>, the following code writes the arrays <code>u</code> and <code>v</code> created in the previous sections:</p><pre><code class="language-julia">using HDF5
using MPI
using PencilFFTs

#= code from previous sections... =#

info = MPI.Info()

ph5open(&quot;fields.h5&quot;, &quot;w&quot;, comm, info) do ff
    ff[&quot;u&quot;] = u
    ff[&quot;v&quot;] = v
end</code></pre><p>Note that, for this to work, the code in <a href="#tutorial:creating_plans">Creating plans</a> must be modified so that HDF5 is loaded before PencilFFTs, since HDF5 is lazy-loaded using <a href="https://github.com/JuliaPackaging/Requires.jl">Requires</a>.</p><p>The following code reads back the datasets into <code>PencilArray</code>s:</p><pre><code class="language-julia">u_read = similar(u)
v_read = similar(v)

ph5open(&quot;fields.h5&quot;, &quot;r&quot;, comm, info) do ff
    read!(ff, u_read, &quot;u&quot;)
    read!(ff, v_read, &quot;v&quot;)
end

@assert u == u_read
@assert v == v_read</code></pre><h3 id="Data-layout-in-files"><a class="docs-heading-anchor" href="#Data-layout-in-files">Data layout in files</a><a id="Data-layout-in-files-1"></a><a class="docs-heading-anchor-permalink" href="#Data-layout-in-files" title="Permalink"></a></h3><p>In our example, the <code>v</code> array, being the output of a distributed transform, has its dimensions permuted in memory. This was discussed in <a href="#tutorial:output_data_layout">Output data layout</a>. For performance reasons, data is written to the HDF5 file in memory order, and thus the dimensions of the <code>v</code> array in the file are permuted with respect to those of the input array. This detail is important if one wishes to read the data from a different application.</p><h3 id="More-documentation"><a class="docs-heading-anchor" href="#More-documentation">More documentation</a><a id="More-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#More-documentation" title="Permalink"></a></h3><p>The Parallel I/O feature is documented in its dedicated section of the <a href="https://jipolanco.github.io/PencilArrays.jl/dev/PencilIO/">PencilArrays docs</a>. In particular, a short step-by-step guide is provided on how to set-up the MPI.jl and HDF5.jl packages in order to make things work. This is not trivial, as it requires the HDF5 libraries to be built with parallel support, and linked to same MPI libraries used by MPI.jl.</p><h2 id="Further-reading"><a class="docs-heading-anchor" href="#Further-reading">Further reading</a><a id="Further-reading-1"></a><a class="docs-heading-anchor-permalink" href="#Further-reading" title="Permalink"></a></h2><p>The examples on the sidebar further illustrate the use of transforms and provide an introduction to working with MPI-distributed data in the form of <code>PencilArray</code>s.</p><p>In addition to the examples, some useful scripts are available in the <code>test/</code> directory of the <code>PencilFFTs</code> repo. In particular, the <a href="https://github.com/jipolanco/PencilFFTs.jl/blob/master/test/taylor_green.jl"><code>test/taylor_green.jl</code></a> example is a (very simple) fluid dynamics application around the <a href="https://en.wikipedia.org/wiki/Taylor%E2%80%93Green_vortex">Taylor–Green</a> vortex flow.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../examples/in-place/">In-place transforms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 3 September 2020 13:04">Thursday 3 September 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
